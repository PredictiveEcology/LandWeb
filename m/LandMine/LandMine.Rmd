---
title: "LandMine"
author: "Eliot McIntire"
date: "14 January 2017"
output:
  html_document: default
  pdf_document: default
---

# Overview

Landmine is a model created for simulating the natural range of variation for landscapes in the boreal forest.
Written in the 1990s (Andison 1996), it has been widely used by the public and the private sector for various purposes.
This `SpaDES` module is a rewrite of the fire component in native R.

## Current Differences

The current version has not been fully tested and compared with the original version, and there are currently several known differences:

- Fire sizes are taken from a Truncated Pareto distribution, resulting in numerous very small fires, and few large fires.
- Parameters have been not been fitted to the landscapes that are under study in the LandWeb project

# Known species

Landmine requires the following codes as inputs (the genus_spec form below), and converts and groups species as follows. Each of the species groups has its own Rate of Spread (ROS) for fire spreading:

* PINU

    * "Pinu_ban"
    * "Pinu_con" 
    * "Pinu_sp" 
* DECI

    * Betu_pap
    * Popu_bal
    * Popu_tre
    * Lari_lar
    
* PICE_MAR

    * Pice_mar
    
* PICE_GLA

    * Pice_gla
    
* ABIE

    * Abie_sp
    
    
# Usage

To run this Landmine module alone, from an R console, the following should work (*iff* raster inputs for `rstStudyRegion` and `rstFlammable` are available), assuming all R packages are available.
Paths will have be changed for a different user.

To deteremine which packages are used by `LandMine`, run `SpaDES::packages(module = "LandMine")`.

```{r module_usage, eval = FALSE}
library(reproducible)
Require(c("igraph", "SpaDES.core", "raster")) # load also reproducible::Require

workingDir <- file.path(".")
moduleDir <- file.path(workingDir, "m") %>% checkPath()
inputDir <- file.path(workingDir, "inputs") %>% checkPath(create = TRUE)
outputDir <- file.path(workingDir, "outputs") %>% checkPath(create = TRUE)
cacheDir <- file.path(outputDir, "cache") %>% checkPath(create = TRUE)
times <- list(start = 0, end = 13)
parameters <- list(
  #.progress = list(type = "text", interval = 1), # for a progress bar
  ## If there are further modules, each can have its own set of parameters:
  #LandMine = list(flushCachedRandomFRI = TRUE) 
)
modules <- list("LandMine")
rstFlammable <- raster(extent(0,1e5, 0, 1e5), res = 250, vals = 0)

objects <- list(rstFlammable = rstFlammable)
paths <- list(
  cachePath = cacheDir,
  modulePath = moduleDir,
  inputPath = inputDir,
  outputPath = outputDir
)

mySim <- simInit(times = times, params = parameters, modules = modules,
                 objects = objects, paths = paths)

dev()
mySimOut <- spades(mySim, .plotInitialTime = times$start, debug = TRUE)
```

# Testing the burn algorithm

```{r testing, eval=FALSE}
libs <- c("DEoptim", "spatialEco", "data.table", "raster", "parallel")
Require(libs)
s <- simInit(times = times, params = parameters, modules = modules,
                 objects = objects, paths = paths)
attach(s@.envir)
#detach(s@.envir)
attach(s@.envir$LandMine)
#detach(s@.envir$LandMine)
ros <- raster(extent(0,3e5, 0, 3e5), res = 250, vals = 0)
ros <- ros==0
fireSize <- 100000
e <- extent(ros)
# coerce to a SpatialPolygons object
wholeExtentPoly <- as(e, 'SpatialPolygons')  
wholeExtentPoly <- SpatialPolygonsDataFrame(wholeExtentPoly, data = data.frame(ID=1))

```

```{r functions}

burnFun <- function(ros, centreCell, fireSize, 
                    spawnNewActive, sizeCutoffs, wholeExtentPoly) {
  
    burned <- burn1(
      landscape = ros,
      startCells =centreCell,# c(quarterCell, centreCell),
      fireSizes = fireSize,
      spreadProb = 1,
      spreadProbRel = ros,
      spawnNewActive = spawnNewActive,
      sizeCutoffs = sizeCutoffs)
    burnedMap <- raster(ros)
    burnedMap[] <- 0
    
    burnedMap[burned$pixels] <- 1
    LM <- land.metrics(wholeExtentPoly, burnedMap, bkgd = 0, 
                       metrics = c("total.edge", "perimeter.area.frac.dim"))
    list(burnedMap = burnedMap, LM = LM)
}

makeParallel <- function(wantParallel, numClus, cl, funs, libs) {
  if (wantParallel) {
    library(parallel)
    if (is.null(cl)) {
      cl <- parallel::makeCluster(numClus)
    }
    funs <- c(funs)
    parallel::clusterExport(cl,  funs)
    #env <- environment()
    parallel::clusterExport(cl,  "libs", envir = parent.frame())
    parallel::clusterEvalQ(cl, {lapply(libs, library, character.only = TRUE)})
  return(cl)
  }
  
}


wrap <- function(cl = NULL, reps, par, funs, objs, libs) {
  cl <- makeParallel(TRUE, numClus = if(length(cl)) length(cl) else detectCores()-1, cl, c(funs, objs),
               libs)
  objs <- mget(objs, envir = parent.frame())
  parallel::clusterExport(cl,  "objs", envir = parent.frame())
  burnMapList <- parallel::clusterApplyLB(cl, reps, function(r) {
    do.call("burnFun", objs)
  })
  return(list(cl = cl, out = burnMapList))
}

####################################################################
fitSN <- function(sna, ros, centreCell, fireSize, 
                    wholeExtentPoly) {
  
  sizeCutoffs <- 10^sna[5:6]
  sna <- c(10^(sna[1]), 10^(sna[2]), 10^(sna[3]), 10^(sna[4]))
  
  bf <<- burnFun(ros, centreCell, fireSize, 
                    sna, sizeCutoffs, wholeExtentPoly)
  abs(log(bf$LM$perimeter.area.frac.dim) - log(0.007)) + (sum(bf$burnedMap[]) < 9e4) # it needs to get to above 90,000 HA for it to count
}

```

# Optimizing parameters

The following code chunk tries to find values of `spawnNewActive` that creates "reasonable" fire shapes at all sizes.
```{r fit-values, eval=FALSE}
wantParallel <- TRUE
#spawnNewActive = c(0.46, 0.2, 0.26, 0.11)
#sizeCutoffs = c(8e3, 2e4)
spawnNewActive = c(0.1, 0.04, 0.025, 0.01)
sizeCutoffs = c(8e3, 2e4)

centreCell <-
  cellFromRowCol(ros,
  rownr = nrow(ros) / 2,
  colnr = ncol(ros) / 2)
quarterCell <- 
  cellFromRowCol(ros,
  rownr = nrow(ros) / 4,
  colnr = ncol(ros) / 4)


#######################################
###### Set variables
#################################
objs <- c("ros", "centreCell", "fireSize",  
                    "spawnNewActive", "sizeCutoffs", "wholeExtentPoly")
funs <- c("burnFun", "burn1")
libs <- c("SpaDES.tools", "data.table", "raster", "spatialEco")

```


```{r make-cluster}
########################################
### SET UP CLUSTER FOR PARALLEL
numCores <- detectCores() - 1
if (Sys.info()["sysname"]=="Windows") {
  cl <- parallel::makeCluster(numCores)
  
} else if (grepl("W-VIC-A1053", Sys.info()["nodename"])) {
  Require("future")
  NcoresOnEach <- 20
  # make a cluster on 3 machines
  machine1 <- "132.156.148.172"
  machine2 <- "132.156.148.171"
  machine3 <- "localhost"
  clNames <- c(rep(machine1, NcoresOnEach),
               rep(machine2, NcoresOnEach),
               rep(machine3, NcoresOnEach))
  cl <- makeClusterPSOCK(clNames, 
                       homogeneous = FALSE, verbose = TRUE)
  #cl <- parallel::makeCluster(numCores, type = "FORK")
  clusterSetRNGStream(cl, sample(1e8,1))
} else {
  cl <- parallel::makeCluster(numCores, type = "FORK")
  clusterSetRNGStream(cl, sample(1e8,1))
}

if (!inherits(cl[[1]], "forknode")) {

  parallel::clusterExport(cl, funs)
  parallel::clusterExport(cl, objs )
  #env <- environment()
  parallel::clusterExport(cl,  "libs", envir = parent.frame())
  parallel::clusterEvalQ(cl, {lapply(libs, library, character.only = TRUE)})
}

```

```{r optimization}
#################### OPTIMIZATION
outs <- DEoptim(fitSN, lower = c(-1.75, -2, -3, -3, 3, 4), upper = c(-0.5, -0.5, -0.5, -1, 4, 5), 
        control = DEoptim.control(VTR = 0.0001, itermax = 75, cluster = cl), 
        ros = ros, centreCell = centreCell, fireSize = fireSize, 
        wholeExtentPoly = wholeExtentPoly)

```

```{r manual-run}
############# MANUAL RUN

#10,000 hectares burns gave this
spawnNewActive[2:3] <- c(0.0235999945606232, 0.0263073265505955)

#100,000 hectare burns gave this
#spawnNewActive <- 10^c(-1.264780,   -1.970946,   -1.288213,   -2.202580)
spawnNewActive <- 10^c(-0.586503645288758, -1.08108837273903, -2.14391896536108, -1.00221184641123)
sizeCutoffs <- 10^c(3.37711253212765, 4.52040993282571)

sns <- c(-1.733262,   -0.933318,   -2.562183,   -2.493687,    3.064458,    4.812305)
spawnNewActive <- 10^sns[1:4]
sizeCutoffs <- 10^sns[5:6]
#spawnNewActive <- 10^c(-1.646419, -1.815395, -2.809013, -2.613337)
#sizeCutoffs <- 10^c(3.888317,    4.641961)

sns <- structure(c(-0.586503645288758, -1.08108837273903, -2.14391896536108, 
-1.00221184641123, 3.37711253212765, 4.52040993282571), .Names = c("par1", 
"par2", "par3", "par4", "par5", "par6"))
spawnNewActive <- 10^sns[1:4]
sizeCutoffs <- 10^(sns[5:6])

dev()
reps <- paste0("rep", 1:3)

burnedMapList <- wrap(cl = cl, reps = reps, par = TRUE, funs = funs, objs = objs, libs = libs)
names(burnedMapList$out) <- reps
burnedMapList <- purrr::transpose(burnedMapList$out)
rbindlist(burnedMapList$LM)
clearPlot()
Plot(burnedMapList$burnedMap, cols = c("white", "red"), new=FALSE)

# 10000 sna[3] = 0.025 - pafd between 0.005 and 0.007
# 10000 sna[3] = 0.025 - pafd = 0.0060 -- too round



```

